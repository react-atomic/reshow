import path from "path";

const keys = Object.keys;

class NginxPushPlugin {
  constructor(options, assetsStore) {
    // Default options
    this.options = {
      filename: "push.nginx.conf",
      nginxLocation: null,
      ...options,
    };
    this.assetsStore = assetsStore;
  }

  apply(compiler) {
    this.resetFilename();
    const PlugName = "NginxPushWebpackPlugin";
    if (compiler.hooks) {
      compiler.hooks.thisCompilation.tap(PlugName, (compilation) => {
        if (compilation.hooks.processAssets) {
          // Modern: `processAssets` is one of the last hooks before frozen assets.
          // We choose `PROCESS_ASSETS_STAGE_REPORT` which is the last possible
          // stage after which to emit.
          //
          // See:
          // - https://webpack.js.org/api/compilation-hooks/#processassets
          // - https://github.com/FormidableLabs/webpack-stats-plugin/issues/56
          compilation.hooks.processAssets.tapPromise(
            {
              name: PlugName,
              stage: compilation.constructor.PROCESS_ASSETS_STAGE_REPORT,
            },
            () => this.emitStats(compilation)
          );
        } else {
          // Legacy.
          compiler.hooks.emit.tapPromise(PlugName, this.emitStats.bind(this));
        }
      });
    } else {
      // Super-legacy.
      compiler.plugin("emit", this.emitStats.bind(this));
    }
  }

  resetFilename() {
    // convert absolute filename into relative so that webpack can
    // generate it at correct location
    const { filename } = this.options;

    if (path.resolve(filename) === path.normalize(filename)) {
      this.options.filename = path.relative(
        compiler.options.output.path,
        filename
      );
    }
  }

  emitStats(compilation, callback) {
    return (
      Promise.resolve()
        .then(
          () =>
            new Promise((resolve) => {
              setTimeout(() => {
                // get all assets
                const assets = keys(this.assetsStore.current?.chunks || {}).map(
                  (key) => {
                    const item = this.assetsStore.current.chunks[key];
                    return item[0].publicPath;
                  }
                );
                resolve(assets);
              });
            })
        )
        // write assets to nginx
        .then((assets) => this.getNginxConf(assets))
        .then((conf) => {
          const sourcePayload = {
            source: () => conf,
            size: () => conf.length,
          };
          if (compilation.emitAsset) {
            compilation.emitAsset(this.options.filename, sourcePayload);
          } else {
            // Replace the compilation result with the evaluated conf code
            compilation.assets[this.options.filename] = sourcePayload;
          }
        })
        .catch((err) => {
          console.error(err);
          return null;
        })
        .then(() => {
          // eslint-disable-next-line promise/no-callback-in-promise,promise/always-return
          if (callback) {
            return void callback();
          }
        })
    );
  }

  getNginxConf(assets) {
    const { filename, nginxLocation } = this.options;
    const content = [
      `# Automatically generated by NginxPushWebpackPlugin, don't change it manually
# Please include this file in your nginx web server directive
# \`\`\`
#   include ${filename};
# \`\`\``,
    ];

    if (nginxLocation) {
      content.push(`location = ${nginxLocation} {`);
    }

    assets.forEach((asset) => {
      content.push(`  http2_push ${asset};`);
    });

    if (nginxLocation) {
      content.push("}");
    }

    return content.join("\n");
  }
}

export default NginxPushPlugin;
